{% import 'variables-ios.jinja' as ios with context %}
{% import 'variables.jinja' as vars with context %}
{{ (ios.project_name + '/Operations/' + class_prefix + 'Operation')|start_of_file -}}
{{- ios.file_header(class_prefix + 'OperationBuilder.h') }}

#import "{{ class_prefix }}Operation.h"
#import <AFNetworking/AFNetworking.h>
#import "{{ class_prefix }}JSONable.h"

#ifndef {{ class_prefix }}LogDebug
#define {{ class_prefix }}LogDebug(fmt, ...) NSLog(fmt, ##__VA_ARGS__)
#endif

#ifndef {{ class_prefix }}LogInfo
#define {{ class_prefix }}LogInfo(fmt, ...) NSLog(fmt, ##__VA_ARGS__)
#endif

#ifndef {{ class_prefix }}LogWarn
#define {{ class_prefix }}LogWarn(fmt, ...) NSLog(fmt, ##__VA_ARGS__)
#endif

#ifndef {{ class_prefix }}LogError
#define {{ class_prefix }}LogError(fmt, ...) NSLog(fmt, ##__VA_ARGS__)
#endif

@interface {{ class_prefix }}Operation ()

@property (atomic, strong) NSURLSessionTask *task;
@property (nonatomic, getter = isFinished, readwrite)  BOOL finished;
@property (nonatomic, getter = isExecuting, readwrite) BOOL executing;

@end

@implementation {{ class_prefix }}Operation

@synthesize finished  = _finished;
@synthesize executing = _executing;

- (instancetype)init
{
    if((self = [super init]) == nil) return nil;
    
    _finished  = NO;
    _executing = NO;
    
    return self;
}

- (void)setupDataTask
{
    AFHTTPRequestSerializer *serializer;
    id parameters;
    if(self.consumesJSON) {
        serializer = self.class.jsonSerializer;
        id<{{ class_prefix }}JSONable> jsonable = self.parameters;
        parameters = [jsonable toJSON];
    }
    else {
        serializer = self.class.httpSerializer;
        parameters = self.parameters;
    }
    
    AFHTTPSessionManager* sessionManager;
    if(self.isFileDownload) {
        sessionManager = [*self.class.jsonSessionManager copy];
    }
    else if(self.produces != nil && [self.produces containsObject:@"text/html"]) {
        sessionManager = *self.class.httpSessionManager;
    }
    else {
        sessionManager = *self.class.jsonSessionManager;
    }

    NSString* URLString = [NSURL URLWithString:self.URLString relativeToURL:sessionManager.baseURL].absoluteString;
    
    NSError *error;
    
    NSMutableURLRequest *request;
    if(self.isMultipart) {
        request = [serializer
         multipartFormRequestWithMethod:self.method
         URLString:URLString
         parameters:parameters
         constructingBodyWithBlock:^(id<AFMultipartFormData>  _Nonnull formData) {
             //! \todo:: Implement this
         }
         error:&error];
    }
    else {
        request = [serializer
         requestWithMethod:self.method
         URLString:URLString
         parameters:parameters
         error:&error];
    }
    
    if(self.consumesJSON) {
        [request setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
    }
    
    for(NSString* key in *self.class.defaultHeaders) {
        [request setValue:(*self.class.defaultHeaders)[key] forHTTPHeaderField:key];
    }
    
    if(self.headers != nil) {
        for(NSString* key in self.headers) {
            [request setValue:self.headers[key] forHTTPHeaderField:key];
        }
    }
    
    __weak {{ class_prefix }}Operation* weakSelf = self;
    
    if(self.securityDefinition != nil) {
        [request setValue:self.class.apiKeys[self.securityDefinition] forHTTPHeaderField:@"Authorization"];
    }
    
    void(^completion)(NSURLResponse * _Nonnull, id  _Nullable, NSError * _Nullable) = ^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {
        {{ class_prefix }}LogDebug(@"Response: %@", response);
        weakSelf.error = error;
        weakSelf.response = response;
        if(error != nil) {
            {{ class_prefix }}LogError(@"Request failed. %@", error);
            if([responseObject isKindOfClass:NSData.class]) {
                NSDictionary* dictionary = [NSJSONSerialization JSONObjectWithData:responseObject options:0 error:nil];
                {{ class_prefix }}LogError(@"Response Error: %@", dictionary);
                weakSelf.errorResponseObject = dictionary;
            }
            else {
                weakSelf.errorResponseObject = responseObject; // This will parse if needed.
            }
        }
        else {
            {{ class_prefix }}LogInfo(@"Request succeeded.");
            if([responseObject isKindOfClass:NSData.class]) {
                NSString* responseString = [NSString stringWithCString:((NSData*)responseObject).bytes encoding:sessionManager.responseSerializer.stringEncoding];
                weakSelf.responseObject = responseString;
                {{ class_prefix }}LogDebug(@"Response: %@", responseString);
            }
            else {
                {{ class_prefix }}LogDebug(@"Response: %@", responseObject);
                weakSelf.responseObject = responseObject; // This will parse if needed.
            }
        }
        [weakSelf completeOperation];
    };
    
    if(self.isFileDownload) {
        [sessionManager setDataTaskDidReceiveResponseBlock:^NSURLSessionResponseDisposition(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLResponse * _Nonnull response) {
            NSUInteger statusCode = ((NSHTTPURLResponse*)response).statusCode;
            if(statusCode >= 200 && statusCode < 300) {
                {{ class_prefix }}LogDebug(@"Converting data operation to download operation.");
                return NSURLSessionResponseBecomeDownload;
            }
            else {
                return NSURLSessionResponseAllow;
            }
        }];
        __weak typeof(self) weakSelf = self;
        __weak typeof(sessionManager) weakSessionManager = sessionManager;
        [sessionManager setDataTaskDidBecomeDownloadTaskBlock:^(NSURLSession * _Nonnull session, NSURLSessionDataTask * _Nonnull dataTask, NSURLSessionDownloadTask * _Nonnull downloadTask) {
            weakSelf.task = downloadTask;
            [weakSessionManager setDownloadTaskDidFinishDownloadingBlock:^NSURL * _Nullable(NSURLSession * _Nonnull session, NSURLSessionDownloadTask * _Nonnull downloadTask, NSURL * _Nonnull location) {
                {{ class_prefix }}LogDebug(@"File finished downloading.");
                NSURL* filePath = [weakSelf filepath];
                return filePath;
            }];
        }];
    }
    
    self.task =
    [sessionManager
     dataTaskWithRequest:request
     completionHandler:completion];
}

+ (void)setURLRoot:(NSString*)host
{
    *self.httpSessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:host]];
    (*self.httpSessionManager).responseSerializer = [AFHTTPResponseSerializer serializer];
    *self.jsonSessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:host]];
}

+ (AFHTTPSessionManager * __strong *)jsonSessionManager
{
    static AFHTTPSessionManager* client = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        client = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@"https://localhost:10010"]];
    });
    return &client;
}

+ (AFHTTPSessionManager * __strong *)httpSessionManager
{
    static AFHTTPSessionManager* client = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        client = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@"https://localhost:10010"]];
        client.responseSerializer = [AFHTTPResponseSerializer serializer];
    });
    return &client;
}

+ (void)pinPublicKeysForCertificatesNamed:(NSArray<NSString*>*)names
{
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    NSMutableSet* certificates = [NSMutableSet set];
    for(NSString* name in names) {
        NSString* path = [bundle pathForResource:name ofType:@"cer"];
        [certificates addObject:[NSData dataWithContentsOfFile:path]];
    }
    (*self.httpSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey withPinnedCertificates:[certificates copy]];
    (*self.jsonSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey withPinnedCertificates:[certificates copy]];
}

+ (void)pinCertificatesNamed:(NSArray<NSString*>*)names
{
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    NSMutableSet* certificates = [NSMutableSet set];
    for(NSString* name in names) {
        NSString* path = [bundle pathForResource:name ofType:@"cer"];
        [certificates addObject:[NSData dataWithContentsOfFile:path]];
    }
    (*self.httpSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:[certificates copy]];
    (*self.jsonSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:[certificates copy]];
}

+ (void)pinPublicKeyForCertificateNamed:(NSString*)name
{
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    NSString* path = [bundle pathForResource:name ofType:@"cer"];
    NSSet *certificate = [NSSet setWithObject:[NSData dataWithContentsOfFile:path]];
    (*self.httpSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey withPinnedCertificates:certificate];
    (*self.jsonSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey withPinnedCertificates:certificate];
}

+ (void)pinCertificateNamed:(NSString*)name
{
    NSBundle *bundle = [NSBundle bundleForClass:[self class]];
    NSString* path = [bundle pathForResource:name ofType:@"cer"];
    NSSet *certificate = [NSSet setWithObject:[NSData dataWithContentsOfFile:path]];
    (*self.httpSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:certificate];
    (*self.jsonSessionManager).securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:certificate];
}

+ (void)allowInvalidCertificates
{
    (*self.httpSessionManager).securityPolicy.allowInvalidCertificates = YES;
    (*self.jsonSessionManager).securityPolicy.allowInvalidCertificates = YES;
}

+ (AFHTTPRequestSerializer*)jsonSerializer
{    
    static AFJSONRequestSerializer* serializer = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        serializer = [AFJSONRequestSerializer serializer];
    });
    //! \todo Set defaults for this serializer.
    return serializer;
}

+ (AFHTTPRequestSerializer*)httpSerializer
{
    static AFHTTPRequestSerializer* serializer = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        serializer = [AFHTTPRequestSerializer serializer];
    });
    //! \todo Set defaults for this serializer.
    return serializer;
}

+ (NSMutableDictionary*)apiKeys
{
    static NSMutableDictionary* keys = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        keys = [NSMutableDictionary dictionary];
    });
    return keys;
}

+ (void)setApiKey:(NSString*)token forSecurityDefinition:(NSString*)securityName
{
    self.apiKeys[securityName] = token;
}

+ (void)setHeaderValue:(NSString*)value forHeader:(NSString*)header
{
    (*self.defaultHeaders)[header] = value;
}

+ (NSMutableDictionary* __strong *)defaultHeaders
{
    static NSMutableDictionary* dict = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        dict = [NSMutableDictionary dictionary];
    });
    return &dict;
}

+ (instancetype)operationWithBuilderBlock:(void(^)(id<{{ class_prefix }}OperationBuilder> *builder))builderBlock
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (NSString*)method
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (NSString*)URLString
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (NSDictionary*)headers
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (id)parameters
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (BOOL)consumesJSON
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (NSSet<NSString*>*)produces
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (BOOL)isMultipart
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (BOOL)isFileDownload
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (NSURL*)filepath
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (NSString*)securityDefinition
{
    [[NSException exceptionWithName:@"GiantError" reason:@"Operation cannot be instantiated directly. Use an Operation subclass." userInfo:@{}] raise];
    return nil;
}

- (void)start 
{
    if ([self isCancelled]) {
        self.finished = YES;
        return;
    }
    self.executing = YES;
    [self main];
}

- (void)main 
{
    {{ class_prefix }}LogInfo(@"Starting REST Operation");
    {{ class_prefix }}LogDebug(@"%@", self.task.currentRequest);
    {{ class_prefix }}LogDebug(@"%@", self.task.currentRequest.allHTTPHeaderFields);
    if(self.task.currentRequest.HTTPBody != nil) {
        {{ class_prefix }}LogDebug(@"%@", [NSString stringWithCString:self.task.currentRequest.HTTPBody.bytes encoding:NSUTF8StringEncoding]);
    }
    [self.task resume];
}

- (void)cancel
 {
    [self.task cancel];
    [super cancel];
}
             
- (void)completeOperation 
{
    self.task = nil;
    self.executing = NO;
    self.finished  = YES;
}

#pragma mark - NSOperation methods

- (BOOL)isAsynchronous
{
    return YES;
}

- (BOOL)isExecuting 
{
    @synchronized(self) {
        return _executing;
    }
}

- (BOOL)isFinished 
{
    @synchronized(self) {
        return _finished;
    }
}

- (void)setExecuting:(BOOL)executing 
{
    if (_executing != executing) {
        [self willChangeValueForKey:@"isExecuting"];
        @synchronized(self) {
            _executing = executing;
        }
        [self didChangeValueForKey:@"isExecuting"];
    }
}

- (void)setFinished:(BOOL)finished 
{
    [self willChangeValueForKey:@"isFinished"];
    @synchronized(self) {
        if (_finished != finished) {
            _finished = finished;
        }
    }
    [self didChangeValueForKey:@"isFinished"];
}

@end

{%- for operation_name, operation in operations.iteritems() -%}
{%- set class_name = class_prefix + (operation_name|pascal_case) + 'Operation' -%}
{{ (ios.project_name + '/Operations/' + class_name)|start_of_file -}}
{{- ios.file_header(class_name+'.m') }}

#import "{{ class_name }}.h"
#import "{{ class_name }}Builder.h"
#import "AECPJSONable.h"
#import <AFNetworking/AFNetworking.h>
{%- set response_import = operation|response_type_import(class_prefix) -%}
{%- if response_import != '' %}
{{ response_import }}
{%- endif %}
{%- set error_response_import = operation|error_response_type_import(class_prefix) -%}
{%- if error_response_import != '' %}
{{ error_response_import }}
{%- endif %}

@interface {{ class_name }} ()

@property (nonatomic, copy) {{ class_name }}Builder *builder;

@end

@implementation {{ class_name }} 

{%- if (operation|response_type(class_prefix)) != '' %}

@dynamic responseObject;

- (void)setResponseObject:(id)responseObject
{
    {%- if (operation|response_schema).type == 'array' %}
    NSMutableArray* objects = [NSMutableArray array];
    for(id<{{ class_prefix }}JSONable> jsonable in responseObject) {
        [objects addObject:[{{ (operation|response_schema|array_definition_items_type(class_prefix))[:-2] }} fromJSON:jsonable]];
    }
    [super setResponseObject:[objects copy]];
    {% else %}
    [super setResponseObject:[{{ (operation|response_type(class_prefix))[:-2] }} fromJSON:responseObject]];
    {%- endif %}
}
{%- endif %}

{%- if (operation|error_response_type(class_prefix)) != '' %}

@dynamic errorResponseObject;

- (void)setErrorResponseObject:(id)errorResponseObject
{
    {%- if (operation|error_response_schema).type == 'array' %}
    NSMutableArray* objects = [NSMutableArray array];
    for(id<{{ class_prefix }}JSONable> jsonable in errorResponseObject) {
        [objects addObject:[{{ (operation|error_response_schema|array_definition_items_type(class_prefix))[:-2] }} fromJSON:jsonable]];
    }
    [super setErrorResponseObject:[objects copy]];
    {% else %}
    [super setErrorResponseObject:[{{ (operation|error_response_type(class_prefix))[:-2] }} fromJSON:errorResponseObject]];
    {%- endif %}
}
{%- endif %}

+ (instancetype)operationWithBuilderBlock:(void(^)({{ class_name }}Builder *builder))builderBlock
{
    {{ class_name }}Builder *builder = [{{ class_name }}Builder new];
    builderBlock(builder);
    return [builder build];
}

- (instancetype)initWithBuilder:({{ class_name }}Builder *)builder
{
    if((self = [super init]) == nil) return nil;
    
    _builder = [builder copy];
    [self setupDataTask];
    
    return self;
}

- (NSString*)method
{
    return @"{{ operation.method|upper }}";
}

- (NSString*)URLString
{
    NSString* URLString = @"{{ swagger.basePath|remove_trailing_slash }}{{ operation.path_name }}";
    {% for param in operation|parameters_in('path') -%}
    {%- set varname = 'self.builder.' + param.name|camel_case|objc_varname -%}
    URLString = [URLString stringByReplacingOccurrencesOfString:@"{{ '{' + param.name + '}'}}" withString:{{ param|type_to_string(varname) }}];
    {%- endfor %}
    {%- set query_params = operation|parameters_in('query') %}
    {%- if query_params|length > 0 %}
    NSMutableArray* queryParameters = [NSMutableArray array];
    {%- for param in query_params %}
    if(self.builder.{{ param.name|camel_case }} != nil) {
        {%- if param.type == 'array' %}
        [queryParameters addObject:[NSString stringWithFormat:@"{{ param.name }}=%@", [self.builder.{{ param.name|camel_case }} componentsJoinedByString:@","]]];
        {%- else %}
        [queryParameters addObject:[NSString stringWithFormat:@"{{ param.name }}=%@", self.builder.{{ param.name|camel_case }}]];
        {%- endif %}
    }
    {%- endfor %}
    if(queryParameters.count > 0) {
        NSMutableCharacterSet* characterSet = NSCharacterSet.URLQueryAllowedCharacterSet.mutableCopy;
        [characterSet removeCharactersInString:@"+"];
        NSString* encodedParameters = [[queryParameters componentsJoinedByString:@"&"] stringByAddingPercentEncodingWithAllowedCharacters:characterSet];
        URLString = [NSString stringWithFormat:@"%@?%@", URLString, encodedParameters];
    }
    {%- endif %}
    
    return URLString;
}

- (NSDictionary*)headers
{
    {%- set header_params = operation|parameters_in('header') %}
    return @{
    {%- for param in header_params %}
        @"{{ param.name }}": self.builder.{{ param.name|camel_case }},
    {% endfor -%}
    };
}

- (id)parameters
{
    {%- set body_params = operation|parameters_in('body') %}
    {%- set form_params = operation|parameters_in('formData') %}
    {%- if body_params|length > 0 %}
    return self.builder.{{ (body_params|first).name|camel_case }};
    {%- elif form_params|length > 0 %}
    return @{
    {%- for param in form_params %}
        @"{{ param.name }}": self.builder.{{ param.name|camel_case }} ? self.builder.{{ param.name|camel_case }} : [NSNull null],{% endfor %}
    };
    {%- else %}
    return nil;
    {%- endif %}
}

- (BOOL)consumesJSON
{
    {% if 'application/json' in operation.consumes -%}
    return YES;
    {%- else -%}
    return NO;
    {%- endif %}
}

{%- if 'produces' in operation %}

- (NSSet<NSString*>*)produces
{
    return [NSSet setWithArray:@[
        {%- for mimetype in operation.produces %}
        @"{{ mimetype }}",
        {%- endfor %}
    ]];
}
{%- endif %}

- (BOOL)isMultipart
{
    {% if 'multipart/form-data' in operation.consumes -%}
    return YES;
    {%- else -%}
    return NO;
    {%- endif %}
}

- (BOOL)isFileDownload
{
    {% if (operation|response_schema).type == 'file' -%}
    return YES;
    {%- else -%}
    return NO;
    {%- endif %}
}

- (NSURL*)filepath
{
    {% if (operation|response_schema).type == 'file' -%}
    return self.builder.filepath;
    {%- else -%}
    return nil;
    {%- endif %}
}

- (NSString*)securityDefinition
{
    {%- if operation.security|length > 0 %}
    return @"{{ operation.security[0].keys()[0] }}";
    {%- else -%}
    return nil;
    {%- endif %}
}

@end
{% endfor %}